# 模块联邦解决了什么问题

解决了公共模块与公共依赖复用的问题

# 其他常用的复用方法有什么问题

- NPM 发包
  - 只做到了代码层面的共享，仍参与每个依赖方的打包构建
  - 版本难控制，NPM 版本升级，每个依赖方都得升级
- Monorepo
  公共模块作为子项目，之后作为其他子应用的 dependency 引用
  - 同样只做到了代码层面的共享
- Webpack Externals
  常见的微前端代码共享方式，以 CDN 的形式引入，运行时由主应用加载
  - 加载了许多首屏不需要的代码，影响性能
  - 不够灵活，有些公共模块可能并不是每个依赖方都需要的

# 模块联邦详解

- 模块之间可以在运行时互相消费各自的模块
- 分为生产者与消费者
  - 生产者暴露共享模块(共享模块会作为不同的 Webpack Entry 进行构建，因此不影响生产者入口文件大小)
- 消费者
  - 消费生产者提供的模块，可通过动态加载提高性能

## 模块消费过程

1. 生产者将共享模块单独打包同时生成一个 remoteEntry.js 文件(暴露一个全局变量，提供 get 方法，来加载共享模块)
2. 消费者生成 main.js 入口文件及 boostrap.js 启动文件
3. 将 remoteEntry 文件(部署地址)加入自己的 webpack_modules 内
4. 加载 bootstrap.js 时前置加载依赖的共享模块
5. 通过 remoteEntry 文件内暴露的方法将共享的模块(部署地址)加载进来
