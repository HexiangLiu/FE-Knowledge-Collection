# chrome 的多进程架构

每一个站点都会创造一个独立的渲染进程

- 浏览器进程
  - UI 线程
  - 网络线程
  - 存储线程
- 渲染进程
- 插件进程
- GPU 进程

# 输入 URL 回车后发生了什么

1. UI 线程借助网络线程访问站点资源
2. 进行 DNS 域名解析，寻找域名对应的 IP 地址，先在本地查找，找不到则在域名服务器上查询
3. 三次握手建立 TCP 连接
4. 发送 HTTP 请求，网络线程处理响应数据，数据类型若为 HTML(Content-Type)则将数据传递给渲染进程
5. 渲染进程一边加载页面资源并渲染页面
6. 连接结束，四次挥手断开 TCP 连接

# Service Worker

web 开发者控制缓存的技术，运行在渲染进程里
访问开始时网络线程根据域名检查是否有 Service worker 会处理当前地址的请求，如果有， UI 线程找到对应的渲染进程执行 Service Worker 代码

# 渲染进程的渲染过程

1. 解析 HTML 数据生成 DOM(边解析边加载额外资源)

- 预加载 preload
- script async defer

2. 样式计算生成 CSSOM
3. DOM 与 CSSOM 结合生成 Render Tree
4. 布局(Layout Tree)
5. 绘制(在多层上进行)，通过栅格线程光栅化（生成位图）缓存在 GPU 中
6. 若不同的层在绘制时发生相互重叠，需要通过合成线程组合，保障绘制顺序

- 独立于主线程
- 用户交互时，事件从浏览器进程=>渲染进程=>合成线程，根据事件监听的区域决定是否交由主线程处理

7. 合成线程生成合成帧，通过 GPU 渲染出来

- 独立于主线程

# 相关文档

[相关文档](https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3)
